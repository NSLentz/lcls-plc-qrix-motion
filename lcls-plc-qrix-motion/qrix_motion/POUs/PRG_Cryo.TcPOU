<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="PRG_Cryo" Id="{d8649ca7-c26e-4e28-a279-17f291a3cb8e}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_Cryo
VAR
    nCryoRotOutEncoderCounts AT %Q*: ULINT;
    nCryoRotEncoderOffset: ULINT;
    nDiffThetaOutEncoderCounts AT %Q*: ULINT;
    nDiffThetaEncoderOffset: ULINT;
    fb_Cryo_ROT : FB_MotionStage;
    fb_Cryo_X : FB_MotionStage;
    fb_Cryo_Y : FB_MotionStage;
    fb_Cryo_Z : FB_MotionStage;
    bInit : BOOl := TRUE;

    nGantryTolerance: LINT;
    {attribute 'pytmc' := '
        pv: QRIX:CRYO:ROT:bExecuteCouple
        io: io
        field: DESC Write TRUE to couple cryo rotation axis with diffractometer theta axis.
    '}
    bCryoRotDiffThetaExecuteCouple: BOOL := FALSE;
    {attribute 'pytmc' := '
        pv: QRIX:CRYO:ROT:bExecuteDecouple
        io: io
        field: DESC Write FALSE to decouple cryo rotation axis from diffractometer theta axis.
    '}
    bCryoRotDiffThetaExecuteDecouple: BOOL := FALSE;
    {attribute 'TcLinkTo' := '.Count := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-02^EL5042_03_17 - Diff - Theta - 2Theta^FB Inputs Channel 1^Position'}
    stDiffThetaEnc: ST_RenishawAbsEnc;
    {attribute 'TcLinkTo' := '.Count := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL5042_02_16^FB Inputs Channel 2^Position'}
    stCryoRotEnc: ST_RenishawAbsEnc;

    {attribute 'pytmc' := '
        pv: QRIX:DIFF:THETACOUPLING
        io: io
        field: DESC Structure representing cryo and diffractometer theta coupling enablement coordinator.
    '}
    stCryoRotDiffThetaAutoRealignCouple: ST_AutoRealignCouple;
    fbCryoRotDiffThetaAutoRealignCouple: FB_AutoRealignCouple;

    fbCryoRotDiffThetaCoupling: FB_GantryAutoCoupling;

    {attribute 'TcLinkTo' := '.bLeaderDriveReady := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-02^EL7047_03_16 - Diff - Theta^STM Status^Status^Ready;
                              .bFollowDriveReady := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_11^STM Status^Status^Ready
    '}
    {attribute 'pytmc' := '
        pv: QRIX:DIFFCRYO:Coord
        io: io
        field: DESC Structure representing cryo and diffractometer theta coupling enablement coordinator.
    '}
    stCryoRotDiffThetaCoordinateGantryAxisEnable: ST_CoordinateGantryAxisEnable;
    fbCryoRotDiffThetaCoordinateGantryAxisEnable: FB_CoordinateGantryAxisEnable;

    fBraidDiameter: LREAL := 70; // mm

    {attribute 'TcLinkTo' := '.bFollowerDriveReady := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_12^STM Status^Status^Ready
    '}
    {attribute 'pytmc' := '
        pv: QRIX:CRYO:MLC:X
        io: io
        field: DESC Structure representing Cryo X multi-leader coupling.
    '}
    stCryoXMultiLeader: ST_MultiLeaderMotionCoupling;
    fbCryoXMultiLeader: FB_MultiLeaderMotionCoupling;
    {attribute 'TcLinkTo' := '.bFollowerDriveReady := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_14^STM Status^Status^Ready
    '}
    {attribute 'pytmc' := '
        pv: QRIX:CRYO:MLC:Y
        io: io
        field: DESC Structure representing Cryo Y multi-leader coupling.
    '}
    stCryoYMultiLeader: ST_MultiLeaderMotionCoupling;
    fbCryoYMultiLeader: FB_MultiLeaderMotionCoupling;
    {attribute 'TcLinkTo' := '.bFollowerDriveReady := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_15^STM Status^Status^Ready
    '}
    {attribute 'pytmc' := '
        pv: QRIX:CRYO:MLC:Z
        io: io
        field: DESC Structure representing Cryo Z multi-leader coupling.
    '}
    stCryoZMultiLeader: ST_MultiLeaderMotionCoupling;
    fbCryoZMultiLeader: FB_MultiLeaderMotionCoupling;

    {attribute 'TcLinkTo' := '.nMicrostepCounter := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_11^ENC Status compact^Counter value;
                              .bCounterOverflow  := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_11^ENC Status compact^Status^Counter overflow;
                              .bCounterUnderflow := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_11^ENC Status compact^Status^Counter underflow'}
    fbMeasureReferenceVelocityCryoROT: FB_MeasureReferenceVelocity;
    {attribute 'TcLinkTo' := '.nMicrostepCounter := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_12^ENC Status compact^Counter value;
                              .bCounterOverflow  := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_12^ENC Status compact^Status^Counter overflow;
                              .bCounterUnderflow := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_12^ENC Status compact^Status^Counter underflow'}
    fbMeasureReferenceVelocityCryoX: FB_MeasureReferenceVelocity;
    {attribute 'TcLinkTo' := '.nMicrostepCounter := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_14^ENC Status compact^Counter value;
                              .bCounterOverflow  := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_14^ENC Status compact^Status^Counter overflow;
                              .bCounterUnderflow := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_14^ENC Status compact^Status^Counter underflow'}
    fbMeasureReferenceVelocityCryoY: FB_MeasureReferenceVelocity;
    {attribute 'TcLinkTo' := '.nMicrostepCounter := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_15^ENC Status compact^Counter value;
                              .bCounterOverflow  := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_15^ENC Status compact^Status^Counter overflow;
                              .bCounterUnderflow := TIID^Device 1 (EtherCAT)^B950-233-WALL-S-R01-DRL-01^EL7047_02_15^ENC Status compact^Status^Counter underflow'}
    fbMeasureReferenceVelocityCryoZ: FB_MeasureReferenceVelocity;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
IF bInit THEN
    bInit := FALSE;

    Main.M46.bHardwareEnable := TRUE;
    Main.M46.bPowerSelf := TRUE;
    Main.M46.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    Main.M46.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    Main.M46.fVelocity := 0.1;

    Main.M47.bHardwareEnable := TRUE;
    Main.M47.bPowerSelf := TRUE;
    Main.M47.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    Main.M47.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    Main.M47.fVelocity := 0.1;

    Main.M48.bHardwareEnable := TRUE;
    Main.M48.bPowerSelf := TRUE;
    Main.M48.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    Main.M48.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    Main.M48.fVelocity := 0.1;

    Main.M49.bHardwareEnable := TRUE;
    Main.M49.bPowerSelf := TRUE;
    Main.M49.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    Main.M49.nEnableMode := ENUM_StageEnableMode.NEVER; // ENUM_StageEnableMode.DURING_MOTION;
    Main.M49.fVelocity := 0.1;
    Main.M49.bLimitBackwardEnable := TRUE;
    Main.M49.bLimitForwardEnable := TRUE;

    // Encoder count offset in order to shift the overflow point.
    nCryoRotEncoderOffset := 1073741824;
    // Encoder count offset in order to shift the overflow point.
    nDiffThetaEncoderOffset := 1073741824;
    // 0.000000083819 deg/inc => 11,930,469.225 inc/degree
    // For 1 degree tolerance, need 11930469 inc
    nGantryTolerance := 11930469;
    stCryoRotDiffThetaCoordinateGantryAxisEnable.bEnable := TRUE;
    // Allow setting of the reference position for gantry diff limit calculation
    stDiffThetaEnc.Ref := 121223792;
    stCryoRotEnc.Ref   := 0;

    stCryoXMultiLeader.bUseDynamicLimits := TRUE;
    stCryoYMultiLeader.bUseDynamicLimits := TRUE;
    stCryoZMultiLeader.bUseDynamicLimits := TRUE;

    //stCryoXMultiLeader.bEnable := TRUE;
    //stCryoYMultiLeader.bEnable := TRUE;
    //stCryoZMultiLeader.bEnable := TRUE;

    stCryoXMultiLeader.fTargetVel := 1;
    stCryoXMultiLeader.fTargetAcc := 100;
    stCryoXMultiLeader.stPos.fMax := 20;
    stCryoXMultiLeader.stVel.fMax := 5;
    stCryoXMultiLeader.stAcc.fMax := 100;
    stCryoXMultiLeader.stPos.fMin := -20;
    stCryoXMultiLeader.stVel.fMin := -5;
    stCryoXMultiLeader.stAcc.fMin := -100;

    stCryoYMultiLeader.fTargetVel := 0.5;
    stCryoYMultiLeader.fTargetAcc := 100;
    stCryoYMultiLeader.stPos.fMax := 100;
    stCryoYMultiLeader.stVel.fMax := 5;
    stCryoYMultiLeader.stAcc.fMax := 100;
    stCryoYMultiLeader.stPos.fMin := 0;
    stCryoYMultiLeader.stVel.fMin := -5;
    stCryoYMultiLeader.stAcc.fMin := -100;
END_IF

// Offset the raw value to ensure the rollover point is not in the path of motion.
// offset of 90 degrees negative for -90 to 270 degree range. 90 degrees because 90/360*2^32 = 1,073,741,824.
nCryoRotOutEncoderCounts   :=  stCryoRotEnc.Count + nCryoRotEncoderOffset;
nDiffThetaOutEncoderCounts :=  UDINT_TO_ULINT(ULINT_TO_UDINT(stDiffThetaEnc.Count)) + nDiffThetaEncoderOffset;

stCryoRotEnc.Count := stCryoRotEnc.Count + nCryoRotEncoderOffset;
stDiffThetaEnc.Count := UDINT_TO_ULINT(ULINT_TO_UDINT(stDiffThetaEnc.Count)) + nDiffThetaEncoderOffset;

// Cryo Rotation and Diffractometer Theta Coupling
fbCryoRotDiffThetaCoupling(
    nGantryTol 			:= nGantryTolerance,
    Master				:= Main.M34,
    MasterEnc			:= stDiffThetaEnc,
    Slave				:= Main.M49,
    SlaveEnc			:= stCryoRotEnc,
    bExecuteCouple 		:= stCryoRotDiffThetaAutoRealignCouple.bExecuteCouple,
    bExecuteDecouple 	:= stCryoRotDiffThetaAutoRealignCouple.bExecuteDecouple
);

fbCryoRotDiffThetaAutoRealignCouple(
    stMotionStageLeader:=Main.M34,
    stMotionStageFollow:=Main.M49,
    stAutoRealignCouple:=stCryoRotDiffThetaAutoRealignCouple
);

(*fbCryoRotDiffThetaCoordinateGantryAxisEnable(
    stMotionStageLeader:=Main.M34,
    stMotionStageFollow:=Main.M49,
    stCoordinateGantryAxisEnable:=stCryoRotDiffThetaCoordinateGantryAxisEnable
);*)

Main.M49.bEnable := TRUE;

fb_Cryo_ROT(stMotionStage:=Main.M49);

IF NOT stCryoXMultiLeader.bEnable THEN
    Main.M46.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
END_IF
IF NOT stCryoYMultiLeader.bEnable THEN
    Main.M47.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
END_IF
IF NOT stCryoZMultiLeader.bEnable THEN
    Main.M48.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
END_IF

stCryoXMultiLeader.fTargetPos :=
    Main.M28.Axis.NcToPlc.ActPos * cos(Main.M32.Axis.NcToPlc.ActPos * 3.1415 / 180) +
    Main.M29.Axis.NcToPlc.ActPos * sin(Main.M32.Axis.NcToPlc.ActPos * 3.1415 / 180);
fbCryoXMultiLeader(
    stMotionStageFollow:=Main.M46,
    stMultiLeaderMotionCoupling:=stCryoXMultiLeader,
    tTimeout:=T#5s
);

stCryoYMultiLeader.fTargetPos := 60 - ABS(fBraidDiameter * (1 - Cos(Main.M32.Axis.NcToPlc.ActPos * 3.1415 / 180)));
fbCryoYMultiLeader(
    stMotionStageFollow:=Main.M47,
    stMultiLeaderMotionCoupling:=stCryoYMultiLeader,
    tTimeout:=T#5s
);
fbCryoZMultiLeader(
    stMotionStageFollow:=Main.M48,
    stMultiLeaderMotionCoupling:=stCryoZMultiLeader,
    tTimeout:=T#5s
);

fb_Cryo_X(stMotionStage:=Main.M46);
fb_Cryo_Y(stMotionStage:=Main.M47);
fb_Cryo_Z(stMotionStage:=Main.M48);

fbMeasureReferenceVelocityCryoX(
    stMotionStage:=Main.M46,
    nMicrostepsPerStep:=64,
    bBusy=>,
    fMeasuredReferenceVelocity=>
);
fbMeasureReferenceVelocityCryoY(
    stMotionStage:=Main.M47,
    nMicrostepsPerStep:=64,
    bBusy=>,
    fMeasuredReferenceVelocity=>
);
fbMeasureReferenceVelocityCryoZ(
    stMotionStage:=Main.M48,
    nMicrostepsPerStep:=64,
    bBusy=>,
    fMeasuredReferenceVelocity=>
);
fbMeasureReferenceVelocityCryoROT(
    stMotionStage:=Main.M49,
    nMicrostepsPerStep:=64,
    bBusy=>,
    fMeasuredReferenceVelocity=>
);
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>